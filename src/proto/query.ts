/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.15.6
 * source: query.proto
 * git: https://github.com/thesayyn/protoc-gen-ts
 * buymeacoffee: https://www.buymeacoffee.com/thesayyn
 *  */
import * as dependency_1 from "./google/protobuf/any";
import * as dependency_2 from "./google/protobuf/wrappers";
import * as pb_1 from "google-protobuf";
export namespace stargate {
    export enum Consistency {
        ANY = 0,
        ONE = 1,
        TWO = 2,
        THREE = 3,
        QUORUM = 4,
        ALL = 5,
        LOCAL_QUORUM = 6,
        EACH_QUORUM = 7,
        SERIAL = 8,
        LOCAL_SERIAL = 9,
        LOCAL_ONE = 10
    }
    export class ConsistencyValue extends pb_1.Message {
        constructor(data?: any[] | {
            value?: Consistency;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getField(this, 1) as Consistency;
        }
        set value(value: Consistency) {
            pb_1.Message.setField(this, 1, value);
        }
        toObject() {
            const data: {
                value?: Consistency;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value !== undefined)
                writer.writeEnum(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConsistencyValue {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConsistencyValue();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ConsistencyValue {
            return ConsistencyValue.deserialize(bytes);
        }
    }
    export class Collection extends pb_1.Message {
        constructor(data?: any[] | {
            elements?: Value[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("elements" in data && data.elements != undefined) {
                    this.elements = data.elements;
                }
            }
        }
        get elements() {
            return pb_1.Message.getRepeatedWrapperField(this, Value, 1) as Value[];
        }
        set elements(value: Value[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        toObject() {
            const data: {
                elements?: ReturnType<typeof Value.prototype.toObject>[];
            } = {};
            if (this.elements != null) {
                data.elements = this.elements.map((item: Value) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.elements !== undefined)
                writer.writeRepeatedMessage(1, this.elements, (item: Value) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Collection {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Collection();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.elements, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Value.deserialize(reader), Value));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Collection {
            return Collection.deserialize(bytes);
        }
    }
    export class UdtValue extends pb_1.Message {
        constructor(data?: any[] | {
            fields?: Map<string, Value>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("fields" in data && data.fields != undefined) {
                    this.fields = data.fields;
                }
            }
            if (!this.fields)
                this.fields = new Map()
        }
        get fields() {
            return pb_1.Message.getField(this, 1) as any as Map<string, Value>;
        }
        set fields(value: Map<string, Value>) {
            pb_1.Message.setField(this, 1, value as any);
        }
        toObject() {
            const data: {
                fields?: {
                    [key: string]: ReturnType<typeof Value.prototype.toObject>;
                };
            } = {};
            if (this.fields.size > 0) {
                data.fields = Object.fromEntries(Array.from(this.fields).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            for (const [key, value] of this.fields) {
                writer.writeMessage(1, this.fields, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                })
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UdtValue {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new UdtValue();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message, () => (pb_1.Map as any).deserializeBinary(message.fields, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Value.deserialize(reader))
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): UdtValue {
            return UdtValue.deserialize(bytes);
        }
    }
    export class Uuid extends pb_1.Message {
        constructor(data?: any[] | {
            msb?: number;
            lsb?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("msb" in data && data.msb != undefined) {
                    this.msb = data.msb;
                }
                if ("lsb" in data && data.lsb != undefined) {
                    this.lsb = data.lsb;
                }
            }
        }
        get msb() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set msb(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get lsb() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set lsb(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                msb?: number;
                lsb?: number;
            } = {};
            if (this.msb != null) {
                data.msb = this.msb;
            }
            if (this.lsb != null) {
                data.lsb = this.lsb;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.msb !== undefined)
                writer.writeFixed64(1, this.msb);
            if (this.lsb !== undefined)
                writer.writeFixed64(2, this.lsb);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Uuid {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Uuid();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.msb = reader.readFixed64();
                        break;
                    case 2:
                        message.lsb = reader.readFixed64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Uuid {
            return Uuid.deserialize(bytes);
        }
    }
    export class Varint extends pb_1.Message {
        constructor(data?: any[] | {
            value?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getField(this, 1) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        toObject() {
            const data: {
                value?: Uint8Array;
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value !== undefined)
                writer.writeBytes(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Varint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Varint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Varint {
            return Varint.deserialize(bytes);
        }
    }
    export class Decimal extends pb_1.Message {
        constructor(data?: any[] | {
            scale?: number;
            value?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("scale" in data && data.scale != undefined) {
                    this.scale = data.scale;
                }
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get scale() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set scale(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get value() {
            return pb_1.Message.getField(this, 3) as Uint8Array;
        }
        set value(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        toObject() {
            const data: {
                scale?: number;
                value?: Uint8Array;
            } = {};
            if (this.scale != null) {
                data.scale = this.scale;
            }
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.scale !== undefined)
                writer.writeUint32(1, this.scale);
            if (this.value !== undefined)
                writer.writeBytes(3, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Decimal {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Decimal();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.scale = reader.readUint32();
                        break;
                    case 3:
                        message.value = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Decimal {
            return Decimal.deserialize(bytes);
        }
    }
    export class Value extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            null?: Value.Null;
            unset?: never;
            int?: never;
            float?: never;
            double?: never;
            boolean?: never;
            string?: never;
            bytes?: never;
            uuid?: never;
            date?: never;
            time?: never;
            collection?: never;
            udt?: never;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: Value.Unset;
            int?: never;
            float?: never;
            double?: never;
            boolean?: never;
            string?: never;
            bytes?: never;
            uuid?: never;
            date?: never;
            time?: never;
            collection?: never;
            udt?: never;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: number;
            float?: never;
            double?: never;
            boolean?: never;
            string?: never;
            bytes?: never;
            uuid?: never;
            date?: never;
            time?: never;
            collection?: never;
            udt?: never;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: never;
            float?: number;
            double?: never;
            boolean?: never;
            string?: never;
            bytes?: never;
            uuid?: never;
            date?: never;
            time?: never;
            collection?: never;
            udt?: never;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: never;
            float?: never;
            double?: number;
            boolean?: never;
            string?: never;
            bytes?: never;
            uuid?: never;
            date?: never;
            time?: never;
            collection?: never;
            udt?: never;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: never;
            float?: never;
            double?: never;
            boolean?: boolean;
            string?: never;
            bytes?: never;
            uuid?: never;
            date?: never;
            time?: never;
            collection?: never;
            udt?: never;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: never;
            float?: never;
            double?: never;
            boolean?: never;
            string?: string;
            bytes?: never;
            uuid?: never;
            date?: never;
            time?: never;
            collection?: never;
            udt?: never;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: never;
            float?: never;
            double?: never;
            boolean?: never;
            string?: never;
            bytes?: Uint8Array;
            uuid?: never;
            date?: never;
            time?: never;
            collection?: never;
            udt?: never;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: never;
            float?: never;
            double?: never;
            boolean?: never;
            string?: never;
            bytes?: never;
            uuid?: Uuid;
            date?: never;
            time?: never;
            collection?: never;
            udt?: never;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: never;
            float?: never;
            double?: never;
            boolean?: never;
            string?: never;
            bytes?: never;
            uuid?: never;
            date?: number;
            time?: never;
            collection?: never;
            udt?: never;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: never;
            float?: never;
            double?: never;
            boolean?: never;
            string?: never;
            bytes?: never;
            uuid?: never;
            date?: never;
            time?: number;
            collection?: never;
            udt?: never;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: never;
            float?: never;
            double?: never;
            boolean?: never;
            string?: never;
            bytes?: never;
            uuid?: never;
            date?: never;
            time?: never;
            collection?: Collection;
            udt?: never;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: never;
            float?: never;
            double?: never;
            boolean?: never;
            string?: never;
            bytes?: never;
            uuid?: never;
            date?: never;
            time?: never;
            collection?: never;
            udt?: UdtValue;
            varint?: never;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: never;
            float?: never;
            double?: never;
            boolean?: never;
            string?: never;
            bytes?: never;
            uuid?: never;
            date?: never;
            time?: never;
            collection?: never;
            udt?: never;
            varint?: Varint;
            decimal?: never;
        } | {
            null?: never;
            unset?: never;
            int?: never;
            float?: never;
            double?: never;
            boolean?: never;
            string?: never;
            bytes?: never;
            uuid?: never;
            date?: never;
            time?: never;
            collection?: never;
            udt?: never;
            varint?: never;
            decimal?: Decimal;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("null" in data && data.null != undefined) {
                    this.null = data.null;
                }
                if ("unset" in data && data.unset != undefined) {
                    this.unset = data.unset;
                }
                if ("int" in data && data.int != undefined) {
                    this.int = data.int;
                }
                if ("float" in data && data.float != undefined) {
                    this.float = data.float;
                }
                if ("double" in data && data.double != undefined) {
                    this.double = data.double;
                }
                if ("boolean" in data && data.boolean != undefined) {
                    this.boolean = data.boolean;
                }
                if ("string" in data && data.string != undefined) {
                    this.string = data.string;
                }
                if ("bytes" in data && data.bytes != undefined) {
                    this.bytes = data.bytes;
                }
                if ("uuid" in data && data.uuid != undefined) {
                    this.uuid = data.uuid;
                }
                if ("date" in data && data.date != undefined) {
                    this.date = data.date;
                }
                if ("time" in data && data.time != undefined) {
                    this.time = data.time;
                }
                if ("collection" in data && data.collection != undefined) {
                    this.collection = data.collection;
                }
                if ("udt" in data && data.udt != undefined) {
                    this.udt = data.udt;
                }
                if ("varint" in data && data.varint != undefined) {
                    this.varint = data.varint;
                }
                if ("decimal" in data && data.decimal != undefined) {
                    this.decimal = data.decimal;
                }
            }
        }
        get null() {
            return pb_1.Message.getWrapperField(this, Value.Null, 1) as Value.Null;
        }
        set null(value: Value.Null) {
            pb_1.Message.setOneofWrapperField(this, 1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get unset() {
            return pb_1.Message.getWrapperField(this, Value.Unset, 2) as Value.Unset;
        }
        set unset(value: Value.Unset) {
            pb_1.Message.setOneofWrapperField(this, 2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get int() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set int(value: number) {
            pb_1.Message.setOneofField(this, 3, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get float() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set float(value: number) {
            pb_1.Message.setOneofField(this, 4, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get double() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set double(value: number) {
            pb_1.Message.setOneofField(this, 5, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get boolean() {
            return pb_1.Message.getField(this, 6) as boolean;
        }
        set boolean(value: boolean) {
            pb_1.Message.setOneofField(this, 6, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get string() {
            return pb_1.Message.getField(this, 7) as string;
        }
        set string(value: string) {
            pb_1.Message.setOneofField(this, 7, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get bytes() {
            return pb_1.Message.getField(this, 8) as Uint8Array;
        }
        set bytes(value: Uint8Array) {
            pb_1.Message.setOneofField(this, 8, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get uuid() {
            return pb_1.Message.getWrapperField(this, Uuid, 9) as Uuid;
        }
        set uuid(value: Uuid) {
            pb_1.Message.setOneofWrapperField(this, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get date() {
            return pb_1.Message.getField(this, 10) as number;
        }
        set date(value: number) {
            pb_1.Message.setOneofField(this, 10, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get time() {
            return pb_1.Message.getField(this, 11) as number;
        }
        set time(value: number) {
            pb_1.Message.setOneofField(this, 11, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get collection() {
            return pb_1.Message.getWrapperField(this, Collection, 12) as Collection;
        }
        set collection(value: Collection) {
            pb_1.Message.setOneofWrapperField(this, 12, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get udt() {
            return pb_1.Message.getWrapperField(this, UdtValue, 13) as UdtValue;
        }
        set udt(value: UdtValue) {
            pb_1.Message.setOneofWrapperField(this, 13, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get varint() {
            return pb_1.Message.getWrapperField(this, Varint, 14) as Varint;
        }
        set varint(value: Varint) {
            pb_1.Message.setOneofWrapperField(this, 14, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get decimal() {
            return pb_1.Message.getWrapperField(this, Decimal, 15) as Decimal;
        }
        set decimal(value: Decimal) {
            pb_1.Message.setOneofWrapperField(this, 15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], value);
        }
        get inner() {
            const cases: {
                [index: number]: "none" | "null" | "unset" | "int" | "float" | "double" | "boolean" | "string" | "bytes" | "uuid" | "date" | "time" | "collection" | "udt" | "varint" | "decimal";
            } = {
                0: "none",
                1: "null",
                2: "unset",
                3: "int",
                4: "float",
                5: "double",
                6: "boolean",
                7: "string",
                8: "bytes",
                9: "uuid",
                10: "date",
                11: "time",
                12: "collection",
                13: "udt",
                14: "varint",
                15: "decimal"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15])];
        }
        toObject() {
            const data: {
                null?: ReturnType<typeof Value.Null.prototype.toObject>;
                unset?: ReturnType<typeof Value.Unset.prototype.toObject>;
                int?: number;
                float?: number;
                double?: number;
                boolean?: boolean;
                string?: string;
                bytes?: Uint8Array;
                uuid?: ReturnType<typeof Uuid.prototype.toObject>;
                date?: number;
                time?: number;
                collection?: ReturnType<typeof Collection.prototype.toObject>;
                udt?: ReturnType<typeof UdtValue.prototype.toObject>;
                varint?: ReturnType<typeof Varint.prototype.toObject>;
                decimal?: ReturnType<typeof Decimal.prototype.toObject>;
            } = {};
            if (this.null != null) {
                data.null = this.null.toObject();
            }
            if (this.unset != null) {
                data.unset = this.unset.toObject();
            }
            if (this.int != null) {
                data.int = this.int;
            }
            if (this.float != null) {
                data.float = this.float;
            }
            if (this.double != null) {
                data.double = this.double;
            }
            if (this.boolean != null) {
                data.boolean = this.boolean;
            }
            if (this.string != null) {
                data.string = this.string;
            }
            if (this.bytes != null) {
                data.bytes = this.bytes;
            }
            if (this.uuid != null) {
                data.uuid = this.uuid.toObject();
            }
            if (this.date != null) {
                data.date = this.date;
            }
            if (this.time != null) {
                data.time = this.time;
            }
            if (this.collection != null) {
                data.collection = this.collection.toObject();
            }
            if (this.udt != null) {
                data.udt = this.udt.toObject();
            }
            if (this.varint != null) {
                data.varint = this.varint.toObject();
            }
            if (this.decimal != null) {
                data.decimal = this.decimal.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.null !== undefined)
                writer.writeMessage(1, this.null, () => this.null.serialize(writer));
            if (this.unset !== undefined)
                writer.writeMessage(2, this.unset, () => this.unset.serialize(writer));
            if (this.int !== undefined)
                writer.writeSint64(3, this.int);
            if (this.float !== undefined)
                writer.writeFloat(4, this.float);
            if (this.double !== undefined)
                writer.writeDouble(5, this.double);
            if (this.boolean !== undefined)
                writer.writeBool(6, this.boolean);
            if (typeof this.string === "string" && this.string.length)
                writer.writeString(7, this.string);
            if (this.bytes !== undefined)
                writer.writeBytes(8, this.bytes);
            if (this.uuid !== undefined)
                writer.writeMessage(9, this.uuid, () => this.uuid.serialize(writer));
            if (this.date !== undefined)
                writer.writeUint32(10, this.date);
            if (this.time !== undefined)
                writer.writeUint64(11, this.time);
            if (this.collection !== undefined)
                writer.writeMessage(12, this.collection, () => this.collection.serialize(writer));
            if (this.udt !== undefined)
                writer.writeMessage(13, this.udt, () => this.udt.serialize(writer));
            if (this.varint !== undefined)
                writer.writeMessage(14, this.varint, () => this.varint.serialize(writer));
            if (this.decimal !== undefined)
                writer.writeMessage(15, this.decimal, () => this.decimal.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Value {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Value();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.null, () => message.null = Value.Null.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.unset, () => message.unset = Value.Unset.deserialize(reader));
                        break;
                    case 3:
                        message.int = reader.readSint64();
                        break;
                    case 4:
                        message.float = reader.readFloat();
                        break;
                    case 5:
                        message.double = reader.readDouble();
                        break;
                    case 6:
                        message.boolean = reader.readBool();
                        break;
                    case 7:
                        message.string = reader.readString();
                        break;
                    case 8:
                        message.bytes = reader.readBytes();
                        break;
                    case 9:
                        reader.readMessage(message.uuid, () => message.uuid = Uuid.deserialize(reader));
                        break;
                    case 10:
                        message.date = reader.readUint32();
                        break;
                    case 11:
                        message.time = reader.readUint64();
                        break;
                    case 12:
                        reader.readMessage(message.collection, () => message.collection = Collection.deserialize(reader));
                        break;
                    case 13:
                        reader.readMessage(message.udt, () => message.udt = UdtValue.deserialize(reader));
                        break;
                    case 14:
                        reader.readMessage(message.varint, () => message.varint = Varint.deserialize(reader));
                        break;
                    case 15:
                        reader.readMessage(message.decimal, () => message.decimal = Decimal.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Value {
            return Value.deserialize(bytes);
        }
    }
    export namespace Value {
        export class Null extends pb_1.Message {
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Null {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Null();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Null {
                return Null.deserialize(bytes);
            }
        }
        export class Unset extends pb_1.Message {
            constructor(data?: any[] | {}) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") { }
            }
            toObject() {
                const data: {} = {};
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Unset {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Unset();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Unset {
                return Unset.deserialize(bytes);
            }
        }
    }
    export class Query extends pb_1.Message {
        constructor(data?: any[] | {
            cql?: string;
            values?: Payload;
            parameters?: QueryParameters;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("cql" in data && data.cql != undefined) {
                    this.cql = data.cql;
                }
                if ("values" in data && data.values != undefined) {
                    this.values = data.values;
                }
                if ("parameters" in data && data.parameters != undefined) {
                    this.parameters = data.parameters;
                }
            }
        }
        get cql() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set cql(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get values() {
            return pb_1.Message.getWrapperField(this, Payload, 2) as Payload;
        }
        set values(value: Payload) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get parameters() {
            return pb_1.Message.getWrapperField(this, QueryParameters, 3) as QueryParameters;
        }
        set parameters(value: QueryParameters) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        toObject() {
            const data: {
                cql?: string;
                values?: ReturnType<typeof Payload.prototype.toObject>;
                parameters?: ReturnType<typeof QueryParameters.prototype.toObject>;
            } = {};
            if (this.cql != null) {
                data.cql = this.cql;
            }
            if (this.values != null) {
                data.values = this.values.toObject();
            }
            if (this.parameters != null) {
                data.parameters = this.parameters.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.cql === "string" && this.cql.length)
                writer.writeString(1, this.cql);
            if (this.values !== undefined)
                writer.writeMessage(2, this.values, () => this.values.serialize(writer));
            if (this.parameters !== undefined)
                writer.writeMessage(3, this.parameters, () => this.parameters.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Query {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Query();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.cql = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.values, () => message.values = Payload.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.parameters, () => message.parameters = QueryParameters.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Query {
            return Query.deserialize(bytes);
        }
    }
    export class Values extends pb_1.Message {
        constructor(data?: any[] | {
            values?: Value[];
            value_names?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("values" in data && data.values != undefined) {
                    this.values = data.values;
                }
                if ("value_names" in data && data.value_names != undefined) {
                    this.value_names = data.value_names;
                }
            }
        }
        get values() {
            return pb_1.Message.getRepeatedWrapperField(this, Value, 1) as Value[];
        }
        set values(value: Value[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get value_names() {
            return pb_1.Message.getField(this, 2) as string[];
        }
        set value_names(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                values?: ReturnType<typeof Value.prototype.toObject>[];
                value_names?: string[];
            } = {};
            if (this.values != null) {
                data.values = this.values.map((item: Value) => item.toObject());
            }
            if (this.value_names != null) {
                data.value_names = this.value_names;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.values !== undefined)
                writer.writeRepeatedMessage(1, this.values, (item: Value) => item.serialize(writer));
            if (this.value_names !== undefined)
                writer.writeRepeatedString(2, this.value_names);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Values {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Values();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.values, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Value.deserialize(reader), Value));
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Values {
            return Values.deserialize(bytes);
        }
    }
    export class Payload extends pb_1.Message {
        constructor(data?: any[] | {
            type?: Payload.Type;
            data?: dependency_1.google.protobuf.Any;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("data" in data && data.data != undefined) {
                    this.data = data.data;
                }
            }
        }
        get type() {
            return pb_1.Message.getField(this, 1) as Payload.Type;
        }
        set type(value: Payload.Type) {
            pb_1.Message.setField(this, 1, value);
        }
        get data() {
            return pb_1.Message.getWrapperField(this, dependency_1.google.protobuf.Any, 2) as dependency_1.google.protobuf.Any;
        }
        set data(value: dependency_1.google.protobuf.Any) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                type?: Payload.Type;
                data?: ReturnType<typeof dependency_1.google.protobuf.Any.prototype.toObject>;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.data != null) {
                data.data = this.data.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type !== undefined)
                writer.writeEnum(1, this.type);
            if (this.data !== undefined)
                writer.writeMessage(2, this.data, () => this.data.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Payload {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Payload();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.data, () => message.data = dependency_1.google.protobuf.Any.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Payload {
            return Payload.deserialize(bytes);
        }
    }
    export namespace Payload {
        export enum Type {
            CQL = 0
        }
    }
    export class QueryParameters extends pb_1.Message {
        constructor(data?: any[] | {
            keyspace?: dependency_2.google.protobuf.StringValue;
            consistency?: ConsistencyValue;
            page_size?: dependency_2.google.protobuf.Int32Value;
            paging_state?: dependency_2.google.protobuf.BytesValue;
            tracing?: boolean;
            skip_metadata?: boolean;
            timestamp?: dependency_2.google.protobuf.Int64Value;
            serial_consistency?: ConsistencyValue;
            now_in_seconds?: dependency_2.google.protobuf.Int32Value;
            tracing_consistency?: ConsistencyValue;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("keyspace" in data && data.keyspace != undefined) {
                    this.keyspace = data.keyspace;
                }
                if ("consistency" in data && data.consistency != undefined) {
                    this.consistency = data.consistency;
                }
                if ("page_size" in data && data.page_size != undefined) {
                    this.page_size = data.page_size;
                }
                if ("paging_state" in data && data.paging_state != undefined) {
                    this.paging_state = data.paging_state;
                }
                if ("tracing" in data && data.tracing != undefined) {
                    this.tracing = data.tracing;
                }
                if ("skip_metadata" in data && data.skip_metadata != undefined) {
                    this.skip_metadata = data.skip_metadata;
                }
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
                if ("serial_consistency" in data && data.serial_consistency != undefined) {
                    this.serial_consistency = data.serial_consistency;
                }
                if ("now_in_seconds" in data && data.now_in_seconds != undefined) {
                    this.now_in_seconds = data.now_in_seconds;
                }
                if ("tracing_consistency" in data && data.tracing_consistency != undefined) {
                    this.tracing_consistency = data.tracing_consistency;
                }
            }
        }
        get keyspace() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.StringValue, 1) as dependency_2.google.protobuf.StringValue;
        }
        set keyspace(value: dependency_2.google.protobuf.StringValue) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get consistency() {
            return pb_1.Message.getWrapperField(this, ConsistencyValue, 2) as ConsistencyValue;
        }
        set consistency(value: ConsistencyValue) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get page_size() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Int32Value, 3) as dependency_2.google.protobuf.Int32Value;
        }
        set page_size(value: dependency_2.google.protobuf.Int32Value) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get paging_state() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.BytesValue, 4) as dependency_2.google.protobuf.BytesValue;
        }
        set paging_state(value: dependency_2.google.protobuf.BytesValue) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get tracing() {
            return pb_1.Message.getField(this, 5) as boolean;
        }
        set tracing(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        get skip_metadata() {
            return pb_1.Message.getField(this, 6) as boolean;
        }
        set skip_metadata(value: boolean) {
            pb_1.Message.setField(this, 6, value);
        }
        get timestamp() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Int64Value, 7) as dependency_2.google.protobuf.Int64Value;
        }
        set timestamp(value: dependency_2.google.protobuf.Int64Value) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get serial_consistency() {
            return pb_1.Message.getWrapperField(this, ConsistencyValue, 8) as ConsistencyValue;
        }
        set serial_consistency(value: ConsistencyValue) {
            pb_1.Message.setWrapperField(this, 8, value);
        }
        get now_in_seconds() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Int32Value, 9) as dependency_2.google.protobuf.Int32Value;
        }
        set now_in_seconds(value: dependency_2.google.protobuf.Int32Value) {
            pb_1.Message.setWrapperField(this, 9, value);
        }
        get tracing_consistency() {
            return pb_1.Message.getWrapperField(this, ConsistencyValue, 10) as ConsistencyValue;
        }
        set tracing_consistency(value: ConsistencyValue) {
            pb_1.Message.setWrapperField(this, 10, value);
        }
        toObject() {
            const data: {
                keyspace?: ReturnType<typeof dependency_2.google.protobuf.StringValue.prototype.toObject>;
                consistency?: ReturnType<typeof ConsistencyValue.prototype.toObject>;
                page_size?: ReturnType<typeof dependency_2.google.protobuf.Int32Value.prototype.toObject>;
                paging_state?: ReturnType<typeof dependency_2.google.protobuf.BytesValue.prototype.toObject>;
                tracing?: boolean;
                skip_metadata?: boolean;
                timestamp?: ReturnType<typeof dependency_2.google.protobuf.Int64Value.prototype.toObject>;
                serial_consistency?: ReturnType<typeof ConsistencyValue.prototype.toObject>;
                now_in_seconds?: ReturnType<typeof dependency_2.google.protobuf.Int32Value.prototype.toObject>;
                tracing_consistency?: ReturnType<typeof ConsistencyValue.prototype.toObject>;
            } = {};
            if (this.keyspace != null) {
                data.keyspace = this.keyspace.toObject();
            }
            if (this.consistency != null) {
                data.consistency = this.consistency.toObject();
            }
            if (this.page_size != null) {
                data.page_size = this.page_size.toObject();
            }
            if (this.paging_state != null) {
                data.paging_state = this.paging_state.toObject();
            }
            if (this.tracing != null) {
                data.tracing = this.tracing;
            }
            if (this.skip_metadata != null) {
                data.skip_metadata = this.skip_metadata;
            }
            if (this.timestamp != null) {
                data.timestamp = this.timestamp.toObject();
            }
            if (this.serial_consistency != null) {
                data.serial_consistency = this.serial_consistency.toObject();
            }
            if (this.now_in_seconds != null) {
                data.now_in_seconds = this.now_in_seconds.toObject();
            }
            if (this.tracing_consistency != null) {
                data.tracing_consistency = this.tracing_consistency.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.keyspace !== undefined)
                writer.writeMessage(1, this.keyspace, () => this.keyspace.serialize(writer));
            if (this.consistency !== undefined)
                writer.writeMessage(2, this.consistency, () => this.consistency.serialize(writer));
            if (this.page_size !== undefined)
                writer.writeMessage(3, this.page_size, () => this.page_size.serialize(writer));
            if (this.paging_state !== undefined)
                writer.writeMessage(4, this.paging_state, () => this.paging_state.serialize(writer));
            if (this.tracing !== undefined)
                writer.writeBool(5, this.tracing);
            if (this.skip_metadata !== undefined)
                writer.writeBool(6, this.skip_metadata);
            if (this.timestamp !== undefined)
                writer.writeMessage(7, this.timestamp, () => this.timestamp.serialize(writer));
            if (this.serial_consistency !== undefined)
                writer.writeMessage(8, this.serial_consistency, () => this.serial_consistency.serialize(writer));
            if (this.now_in_seconds !== undefined)
                writer.writeMessage(9, this.now_in_seconds, () => this.now_in_seconds.serialize(writer));
            if (this.tracing_consistency !== undefined)
                writer.writeMessage(10, this.tracing_consistency, () => this.tracing_consistency.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): QueryParameters {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new QueryParameters();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.keyspace, () => message.keyspace = dependency_2.google.protobuf.StringValue.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.consistency, () => message.consistency = ConsistencyValue.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.page_size, () => message.page_size = dependency_2.google.protobuf.Int32Value.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.paging_state, () => message.paging_state = dependency_2.google.protobuf.BytesValue.deserialize(reader));
                        break;
                    case 5:
                        message.tracing = reader.readBool();
                        break;
                    case 6:
                        message.skip_metadata = reader.readBool();
                        break;
                    case 7:
                        reader.readMessage(message.timestamp, () => message.timestamp = dependency_2.google.protobuf.Int64Value.deserialize(reader));
                        break;
                    case 8:
                        reader.readMessage(message.serial_consistency, () => message.serial_consistency = ConsistencyValue.deserialize(reader));
                        break;
                    case 9:
                        reader.readMessage(message.now_in_seconds, () => message.now_in_seconds = dependency_2.google.protobuf.Int32Value.deserialize(reader));
                        break;
                    case 10:
                        reader.readMessage(message.tracing_consistency, () => message.tracing_consistency = ConsistencyValue.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): QueryParameters {
            return QueryParameters.deserialize(bytes);
        }
    }
    export class TypeSpec extends pb_1.Message {
        constructor(data?: any[] | ({} & (({
            basic?: TypeSpec.Basic;
            map?: never;
            list?: never;
            set?: never;
            udt?: never;
            tuple?: never;
        } | {
            basic?: never;
            map?: TypeSpec.MapFixMe;
            list?: never;
            set?: never;
            udt?: never;
            tuple?: never;
        } | {
            basic?: never;
            map?: never;
            list?: TypeSpec.List;
            set?: never;
            udt?: never;
            tuple?: never;
        } | {
            basic?: never;
            map?: never;
            list?: never;
            set?: TypeSpec.Set;
            udt?: never;
            tuple?: never;
        } | {
            basic?: never;
            map?: never;
            list?: never;
            set?: never;
            udt?: TypeSpec.Udt;
            tuple?: never;
        } | {
            basic?: never;
            map?: never;
            list?: never;
            set?: never;
            udt?: never;
            tuple?: TypeSpec.Tuple;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], [[1, 2, 3, 4, 5, 6]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("basic" in data && data.basic != undefined) {
                    this.basic = data.basic;
                }
                if ("map" in data && data.map != undefined) {
                    this.map = data.map;
                }
                if ("list" in data && data.list != undefined) {
                    this.list = data.list;
                }
                if ("set" in data && data.set != undefined) {
                    this.set = data.set;
                }
                if ("udt" in data && data.udt != undefined) {
                    this.udt = data.udt;
                }
                if ("tuple" in data && data.tuple != undefined) {
                    this.tuple = data.tuple;
                }
            }
        }
        get basic() {
            return pb_1.Message.getField(this, 1) as TypeSpec.Basic;
        }
        set basic(value: TypeSpec.Basic) {
            pb_1.Message.setOneofField(this, 1, [1, 2, 3, 4, 5, 6], value);
        }
        get map() {
            return pb_1.Message.getWrapperField(this, TypeSpec.MapFixMe, 2) as TypeSpec.MapFixMe;
        }
        set map(value: TypeSpec.MapFixMe) {
            pb_1.Message.setOneofWrapperField(this, 2, [1, 2, 3, 4, 5, 6], value);
        }
        get list() {
            return pb_1.Message.getWrapperField(this, TypeSpec.List, 3) as TypeSpec.List;
        }
        set list(value: TypeSpec.List) {
            pb_1.Message.setOneofWrapperField(this, 3, [1, 2, 3, 4, 5, 6], value);
        }
        get set() {
            return pb_1.Message.getWrapperField(this, TypeSpec.Set, 4) as TypeSpec.Set;
        }
        set set(value: TypeSpec.Set) {
            pb_1.Message.setOneofWrapperField(this, 4, [1, 2, 3, 4, 5, 6], value);
        }
        get udt() {
            return pb_1.Message.getWrapperField(this, TypeSpec.Udt, 5) as TypeSpec.Udt;
        }
        set udt(value: TypeSpec.Udt) {
            pb_1.Message.setOneofWrapperField(this, 5, [1, 2, 3, 4, 5, 6], value);
        }
        get tuple() {
            return pb_1.Message.getWrapperField(this, TypeSpec.Tuple, 6) as TypeSpec.Tuple;
        }
        set tuple(value: TypeSpec.Tuple) {
            pb_1.Message.setOneofWrapperField(this, 6, [1, 2, 3, 4, 5, 6], value);
        }
        get spec() {
            const cases: {
                [index: number]: "none" | "basic" | "map" | "list" | "set" | "udt" | "tuple";
            } = {
                0: "none",
                1: "basic",
                2: "map",
                3: "list",
                4: "set",
                5: "udt",
                6: "tuple"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4, 5, 6])];
        }
        toObject() {
            const data: {
                basic?: TypeSpec.Basic;
                map?: ReturnType<typeof TypeSpec.MapFixMe.prototype.toObject>;
                list?: ReturnType<typeof TypeSpec.List.prototype.toObject>;
                set?: ReturnType<typeof TypeSpec.Set.prototype.toObject>;
                udt?: ReturnType<typeof TypeSpec.Udt.prototype.toObject>;
                tuple?: ReturnType<typeof TypeSpec.Tuple.prototype.toObject>;
            } = {};
            if (this.basic != null) {
                data.basic = this.basic;
            }
            if (this.map != null) {
                data.map = this.map.toObject();
            }
            if (this.list != null) {
                data.list = this.list.toObject();
            }
            if (this.set != null) {
                data.set = this.set.toObject();
            }
            if (this.udt != null) {
                data.udt = this.udt.toObject();
            }
            if (this.tuple != null) {
                data.tuple = this.tuple.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.basic !== undefined)
                writer.writeEnum(1, this.basic);
            if (this.map !== undefined)
                writer.writeMessage(2, this.map, () => this.map.serialize(writer));
            if (this.list !== undefined)
                writer.writeMessage(3, this.list, () => this.list.serialize(writer));
            if (this.set !== undefined)
                writer.writeMessage(4, this.set, () => this.set.serialize(writer));
            if (this.udt !== undefined)
                writer.writeMessage(5, this.udt, () => this.udt.serialize(writer));
            if (this.tuple !== undefined)
                writer.writeMessage(6, this.tuple, () => this.tuple.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TypeSpec {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TypeSpec();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.basic = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.map, () => message.map = TypeSpec.MapFixMe.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.list, () => message.list = TypeSpec.List.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.set, () => message.set = TypeSpec.Set.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.udt, () => message.udt = TypeSpec.Udt.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.tuple, () => message.tuple = TypeSpec.Tuple.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): TypeSpec {
            return TypeSpec.deserialize(bytes);
        }
    }
    export namespace TypeSpec {
        export enum Basic {
            CUSTOM = 0,
            ASCII = 1,
            BIGINT = 2,
            BLOB = 3,
            BOOLEAN = 4,
            COUNTER = 5,
            DECIMAL = 6,
            DOUBLE = 7,
            FLOAT = 8,
            INT = 9,
            TEXT = 10,
            TIMESTAMP = 11,
            UUID = 12,
            VARCHAR = 13,
            VARINT = 14,
            TIMEUUID = 15,
            INET = 16,
            DATE = 17,
            TIME = 18,
            SMALLINT = 19,
            TINYINT = 20
        }
        export class MapFixMe extends pb_1.Message {
            constructor(data?: any[] | {
                key?: TypeSpec;
                value?: TypeSpec;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("key" in data && data.key != undefined) {
                        this.key = data.key;
                    }
                    if ("value" in data && data.value != undefined) {
                        this.value = data.value;
                    }
                }
            }
            get key() {
                return pb_1.Message.getWrapperField(this, TypeSpec, 1) as TypeSpec;
            }
            set key(value: TypeSpec) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get value() {
                return pb_1.Message.getWrapperField(this, TypeSpec, 2) as TypeSpec;
            }
            set value(value: TypeSpec) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            toObject() {
                const data: {
                    key?: ReturnType<typeof TypeSpec.prototype.toObject>;
                    value?: ReturnType<typeof TypeSpec.prototype.toObject>;
                } = {};
                if (this.key != null) {
                    data.key = this.key.toObject();
                }
                if (this.value != null) {
                    data.value = this.value.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.key !== undefined)
                    writer.writeMessage(1, this.key, () => this.key.serialize(writer));
                if (this.value !== undefined)
                    writer.writeMessage(2, this.value, () => this.value.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MapFixMe {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MapFixMe();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.key, () => message.key = TypeSpec.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.value, () => message.value = TypeSpec.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): MapFixMe {
                return MapFixMe.deserialize(bytes);
            }
        }
        export class List extends pb_1.Message {
            constructor(data?: any[] | {
                element?: TypeSpec;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("element" in data && data.element != undefined) {
                        this.element = data.element;
                    }
                }
            }
            get element() {
                return pb_1.Message.getWrapperField(this, TypeSpec, 1) as TypeSpec;
            }
            set element(value: TypeSpec) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            toObject() {
                const data: {
                    element?: ReturnType<typeof TypeSpec.prototype.toObject>;
                } = {};
                if (this.element != null) {
                    data.element = this.element.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.element !== undefined)
                    writer.writeMessage(1, this.element, () => this.element.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): List {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new List();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.element, () => message.element = TypeSpec.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): List {
                return List.deserialize(bytes);
            }
        }
        export class Set extends pb_1.Message {
            constructor(data?: any[] | {
                element?: TypeSpec;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("element" in data && data.element != undefined) {
                        this.element = data.element;
                    }
                }
            }
            get element() {
                return pb_1.Message.getWrapperField(this, TypeSpec, 1) as TypeSpec;
            }
            set element(value: TypeSpec) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            toObject() {
                const data: {
                    element?: ReturnType<typeof TypeSpec.prototype.toObject>;
                } = {};
                if (this.element != null) {
                    data.element = this.element.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.element !== undefined)
                    writer.writeMessage(1, this.element, () => this.element.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Set {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Set();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.element, () => message.element = TypeSpec.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Set {
                return Set.deserialize(bytes);
            }
        }
        export class Udt extends pb_1.Message {
            constructor(data?: any[] | {
                fields?: Map<string, TypeSpec>;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("fields" in data && data.fields != undefined) {
                        this.fields = data.fields;
                    }
                }
                if (!this.fields)
                    this.fields = new Map()
            }
            get fields() {
                return pb_1.Message.getField(this, 1) as any as Map<string, TypeSpec>;
            }
            set fields(value: Map<string, TypeSpec>) {
                pb_1.Message.setField(this, 1, value as any);
            }
            toObject() {
                const data: {
                    fields?: {
                        [key: string]: ReturnType<typeof TypeSpec.prototype.toObject>;
                    };
                } = {};
                if (this.fields.size > 0) {
                    data.fields = Object.fromEntries(Array.from(this.fields).map(([key, value]) => [key, value.toObject()]));
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                for (const [key, value] of this.fields) {
                    writer.writeMessage(1, this.fields, () => {
                        writer.writeString(1, key);
                        writer.writeMessage(2, value, () => value.serialize(writer));
                    })
                }
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Udt {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Udt();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message, () => (pb_1.Map as any).deserializeBinary(message.fields, reader, reader.readString, () => {
                                let value;
                                reader.readMessage(message, () => value = TypeSpec.deserialize(reader))
                                return value;
                            }));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Udt {
                return Udt.deserialize(bytes);
            }
        }
        export class Tuple extends pb_1.Message {
            constructor(data?: any[] | {
                elements?: TypeSpec[];
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("elements" in data && data.elements != undefined) {
                        this.elements = data.elements;
                    }
                }
            }
            get elements() {
                return pb_1.Message.getRepeatedWrapperField(this, TypeSpec, 1) as TypeSpec[];
            }
            set elements(value: TypeSpec[]) {
                pb_1.Message.setRepeatedWrapperField(this, 1, value);
            }
            toObject() {
                const data: {
                    elements?: ReturnType<typeof TypeSpec.prototype.toObject>[];
                } = {};
                if (this.elements != null) {
                    data.elements = this.elements.map((item: TypeSpec) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.elements !== undefined)
                    writer.writeRepeatedMessage(1, this.elements, (item: TypeSpec) => item.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Tuple {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Tuple();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.elements, () => pb_1.Message.addToRepeatedWrapperField(message, 1, TypeSpec.deserialize(reader), TypeSpec));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Tuple {
                return Tuple.deserialize(bytes);
            }
        }
    }
    export class ColumnSpec extends pb_1.Message {
        constructor(data?: any[] | {
            type?: TypeSpec;
            name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
            }
        }
        get type() {
            return pb_1.Message.getWrapperField(this, TypeSpec, 1) as TypeSpec;
        }
        set type(value: TypeSpec) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get name() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                type?: ReturnType<typeof TypeSpec.prototype.toObject>;
                name?: string;
            } = {};
            if (this.type != null) {
                data.type = this.type.toObject();
            }
            if (this.name != null) {
                data.name = this.name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type !== undefined)
                writer.writeMessage(1, this.type, () => this.type.serialize(writer));
            if (typeof this.name === "string" && this.name.length)
                writer.writeString(2, this.name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ColumnSpec {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ColumnSpec();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.type, () => message.type = TypeSpec.deserialize(reader));
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ColumnSpec {
            return ColumnSpec.deserialize(bytes);
        }
    }
    export class Traces extends pb_1.Message {
        constructor(data?: any[] | {
            id?: string;
            duration?: number;
            started_at?: number;
            events?: Traces.Event[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("duration" in data && data.duration != undefined) {
                    this.duration = data.duration;
                }
                if ("started_at" in data && data.started_at != undefined) {
                    this.started_at = data.started_at;
                }
                if ("events" in data && data.events != undefined) {
                    this.events = data.events;
                }
            }
        }
        get id() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set id(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get duration() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set duration(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get started_at() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set started_at(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get events() {
            return pb_1.Message.getRepeatedWrapperField(this, Traces.Event, 4) as Traces.Event[];
        }
        set events(value: Traces.Event[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        toObject() {
            const data: {
                id?: string;
                duration?: number;
                started_at?: number;
                events?: ReturnType<typeof Traces.Event.prototype.toObject>[];
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.duration != null) {
                data.duration = this.duration;
            }
            if (this.started_at != null) {
                data.started_at = this.started_at;
            }
            if (this.events != null) {
                data.events = this.events.map((item: Traces.Event) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.id === "string" && this.id.length)
                writer.writeString(1, this.id);
            if (this.duration !== undefined)
                writer.writeInt64(2, this.duration);
            if (this.started_at !== undefined)
                writer.writeInt64(3, this.started_at);
            if (this.events !== undefined)
                writer.writeRepeatedMessage(4, this.events, (item: Traces.Event) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Traces {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Traces();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readString();
                        break;
                    case 2:
                        message.duration = reader.readInt64();
                        break;
                    case 3:
                        message.started_at = reader.readInt64();
                        break;
                    case 4:
                        reader.readMessage(message.events, () => pb_1.Message.addToRepeatedWrapperField(message, 4, Traces.Event.deserialize(reader), Traces.Event));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Traces {
            return Traces.deserialize(bytes);
        }
    }
    export namespace Traces {
        export class Event extends pb_1.Message {
            constructor(data?: any[] | {
                activity?: string;
                source?: string;
                source_elapsed?: number;
                thread?: string;
                event_id?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("activity" in data && data.activity != undefined) {
                        this.activity = data.activity;
                    }
                    if ("source" in data && data.source != undefined) {
                        this.source = data.source;
                    }
                    if ("source_elapsed" in data && data.source_elapsed != undefined) {
                        this.source_elapsed = data.source_elapsed;
                    }
                    if ("thread" in data && data.thread != undefined) {
                        this.thread = data.thread;
                    }
                    if ("event_id" in data && data.event_id != undefined) {
                        this.event_id = data.event_id;
                    }
                }
            }
            get activity() {
                return pb_1.Message.getField(this, 1) as string;
            }
            set activity(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get source() {
                return pb_1.Message.getField(this, 2) as string;
            }
            set source(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get source_elapsed() {
                return pb_1.Message.getField(this, 3) as number;
            }
            set source_elapsed(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get thread() {
                return pb_1.Message.getField(this, 4) as string;
            }
            set thread(value: string) {
                pb_1.Message.setField(this, 4, value);
            }
            get event_id() {
                return pb_1.Message.getField(this, 5) as string;
            }
            set event_id(value: string) {
                pb_1.Message.setField(this, 5, value);
            }
            toObject() {
                const data: {
                    activity?: string;
                    source?: string;
                    source_elapsed?: number;
                    thread?: string;
                    event_id?: string;
                } = {};
                if (this.activity != null) {
                    data.activity = this.activity;
                }
                if (this.source != null) {
                    data.source = this.source;
                }
                if (this.source_elapsed != null) {
                    data.source_elapsed = this.source_elapsed;
                }
                if (this.thread != null) {
                    data.thread = this.thread;
                }
                if (this.event_id != null) {
                    data.event_id = this.event_id;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (typeof this.activity === "string" && this.activity.length)
                    writer.writeString(1, this.activity);
                if (typeof this.source === "string" && this.source.length)
                    writer.writeString(2, this.source);
                if (this.source_elapsed !== undefined)
                    writer.writeInt64(3, this.source_elapsed);
                if (typeof this.thread === "string" && this.thread.length)
                    writer.writeString(4, this.thread);
                if (typeof this.event_id === "string" && this.event_id.length)
                    writer.writeString(5, this.event_id);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Event {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Event();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.activity = reader.readString();
                            break;
                        case 2:
                            message.source = reader.readString();
                            break;
                        case 3:
                            message.source_elapsed = reader.readInt64();
                            break;
                        case 4:
                            message.thread = reader.readString();
                            break;
                        case 5:
                            message.event_id = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): Event {
                return Event.deserialize(bytes);
            }
        }
    }
    export class SchemaChange extends pb_1.Message {
        constructor(data?: any[] | {
            change_type?: SchemaChange.Type;
            target?: SchemaChange.Target;
            keyspace?: string;
            name?: dependency_2.google.protobuf.StringValue;
            argument_types?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [5], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("change_type" in data && data.change_type != undefined) {
                    this.change_type = data.change_type;
                }
                if ("target" in data && data.target != undefined) {
                    this.target = data.target;
                }
                if ("keyspace" in data && data.keyspace != undefined) {
                    this.keyspace = data.keyspace;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("argument_types" in data && data.argument_types != undefined) {
                    this.argument_types = data.argument_types;
                }
            }
        }
        get change_type() {
            return pb_1.Message.getField(this, 1) as SchemaChange.Type;
        }
        set change_type(value: SchemaChange.Type) {
            pb_1.Message.setField(this, 1, value);
        }
        get target() {
            return pb_1.Message.getField(this, 2) as SchemaChange.Target;
        }
        set target(value: SchemaChange.Target) {
            pb_1.Message.setField(this, 2, value);
        }
        get keyspace() {
            return pb_1.Message.getField(this, 3) as string;
        }
        set keyspace(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get name() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.StringValue, 4) as dependency_2.google.protobuf.StringValue;
        }
        set name(value: dependency_2.google.protobuf.StringValue) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get argument_types() {
            return pb_1.Message.getField(this, 5) as string[];
        }
        set argument_types(value: string[]) {
            pb_1.Message.setField(this, 5, value);
        }
        toObject() {
            const data: {
                change_type?: SchemaChange.Type;
                target?: SchemaChange.Target;
                keyspace?: string;
                name?: ReturnType<typeof dependency_2.google.protobuf.StringValue.prototype.toObject>;
                argument_types?: string[];
            } = {};
            if (this.change_type != null) {
                data.change_type = this.change_type;
            }
            if (this.target != null) {
                data.target = this.target;
            }
            if (this.keyspace != null) {
                data.keyspace = this.keyspace;
            }
            if (this.name != null) {
                data.name = this.name.toObject();
            }
            if (this.argument_types != null) {
                data.argument_types = this.argument_types;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.change_type !== undefined)
                writer.writeEnum(1, this.change_type);
            if (this.target !== undefined)
                writer.writeEnum(2, this.target);
            if (typeof this.keyspace === "string" && this.keyspace.length)
                writer.writeString(3, this.keyspace);
            if (this.name !== undefined)
                writer.writeMessage(4, this.name, () => this.name.serialize(writer));
            if (this.argument_types !== undefined)
                writer.writeRepeatedString(5, this.argument_types);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SchemaChange {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SchemaChange();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.change_type = reader.readEnum();
                        break;
                    case 2:
                        message.target = reader.readEnum();
                        break;
                    case 3:
                        message.keyspace = reader.readString();
                        break;
                    case 4:
                        reader.readMessage(message.name, () => message.name = dependency_2.google.protobuf.StringValue.deserialize(reader));
                        break;
                    case 5:
                        pb_1.Message.addToRepeatedField(message, 5, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SchemaChange {
            return SchemaChange.deserialize(bytes);
        }
    }
    export namespace SchemaChange {
        export enum Type {
            CREATED = 0,
            UPDATED = 1,
            DROPPED = 2
        }
        export enum Target {
            KEYSPACE = 0,
            TABLE = 1,
            TYPE = 2,
            FUNCTION = 3,
            AGGREGATE = 4
        }
    }
    export class Response extends pb_1.Message {
        constructor(data?: any[] | ({
            warnings?: string[];
            traces?: Traces;
        } & (({
            result_set?: Payload;
            schema_change?: never;
        } | {
            result_set?: never;
            schema_change?: SchemaChange;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], [[1, 4]]);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("result_set" in data && data.result_set != undefined) {
                    this.result_set = data.result_set;
                }
                if ("schema_change" in data && data.schema_change != undefined) {
                    this.schema_change = data.schema_change;
                }
                if ("warnings" in data && data.warnings != undefined) {
                    this.warnings = data.warnings;
                }
                if ("traces" in data && data.traces != undefined) {
                    this.traces = data.traces;
                }
            }
        }
        get result_set() {
            return pb_1.Message.getWrapperField(this, Payload, 1) as Payload;
        }
        set result_set(value: Payload) {
            pb_1.Message.setOneofWrapperField(this, 1, [1, 4], value);
        }
        get schema_change() {
            return pb_1.Message.getWrapperField(this, SchemaChange, 4) as SchemaChange;
        }
        set schema_change(value: SchemaChange) {
            pb_1.Message.setOneofWrapperField(this, 4, [1, 4], value);
        }
        get warnings() {
            return pb_1.Message.getField(this, 2) as string[];
        }
        set warnings(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get traces() {
            return pb_1.Message.getWrapperField(this, Traces, 3) as Traces;
        }
        set traces(value: Traces) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get result() {
            const cases: {
                [index: number]: "none" | "result_set" | "schema_change";
            } = {
                0: "none",
                1: "result_set",
                4: "schema_change"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 4])];
        }
        toObject() {
            const data: {
                result_set?: ReturnType<typeof Payload.prototype.toObject>;
                schema_change?: ReturnType<typeof SchemaChange.prototype.toObject>;
                warnings?: string[];
                traces?: ReturnType<typeof Traces.prototype.toObject>;
            } = {};
            if (this.result_set != null) {
                data.result_set = this.result_set.toObject();
            }
            if (this.schema_change != null) {
                data.schema_change = this.schema_change.toObject();
            }
            if (this.warnings != null) {
                data.warnings = this.warnings;
            }
            if (this.traces != null) {
                data.traces = this.traces.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.result_set !== undefined)
                writer.writeMessage(1, this.result_set, () => this.result_set.serialize(writer));
            if (this.schema_change !== undefined)
                writer.writeMessage(4, this.schema_change, () => this.schema_change.serialize(writer));
            if (this.warnings !== undefined)
                writer.writeRepeatedString(2, this.warnings);
            if (this.traces !== undefined)
                writer.writeMessage(3, this.traces, () => this.traces.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Response {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Response();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.result_set, () => message.result_set = Payload.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.schema_change, () => message.schema_change = SchemaChange.deserialize(reader));
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        reader.readMessage(message.traces, () => message.traces = Traces.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Response {
            return Response.deserialize(bytes);
        }
    }
    export class Unavailable extends pb_1.Message {
        constructor(data?: any[] | {
            consistency?: Consistency;
            required?: number;
            alive?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("consistency" in data && data.consistency != undefined) {
                    this.consistency = data.consistency;
                }
                if ("required" in data && data.required != undefined) {
                    this.required = data.required;
                }
                if ("alive" in data && data.alive != undefined) {
                    this.alive = data.alive;
                }
            }
        }
        get consistency() {
            return pb_1.Message.getField(this, 1) as Consistency;
        }
        set consistency(value: Consistency) {
            pb_1.Message.setField(this, 1, value);
        }
        get required() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set required(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get alive() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set alive(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        toObject() {
            const data: {
                consistency?: Consistency;
                required?: number;
                alive?: number;
            } = {};
            if (this.consistency != null) {
                data.consistency = this.consistency;
            }
            if (this.required != null) {
                data.required = this.required;
            }
            if (this.alive != null) {
                data.alive = this.alive;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.consistency !== undefined)
                writer.writeEnum(1, this.consistency);
            if (this.required !== undefined)
                writer.writeInt32(2, this.required);
            if (this.alive !== undefined)
                writer.writeInt32(3, this.alive);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Unavailable {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Unavailable();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.consistency = reader.readEnum();
                        break;
                    case 2:
                        message.required = reader.readInt32();
                        break;
                    case 3:
                        message.alive = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Unavailable {
            return Unavailable.deserialize(bytes);
        }
    }
    export class WriteTimeout extends pb_1.Message {
        constructor(data?: any[] | {
            consistency?: Consistency;
            received?: number;
            block_for?: number;
            write_type?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("consistency" in data && data.consistency != undefined) {
                    this.consistency = data.consistency;
                }
                if ("received" in data && data.received != undefined) {
                    this.received = data.received;
                }
                if ("block_for" in data && data.block_for != undefined) {
                    this.block_for = data.block_for;
                }
                if ("write_type" in data && data.write_type != undefined) {
                    this.write_type = data.write_type;
                }
            }
        }
        get consistency() {
            return pb_1.Message.getField(this, 1) as Consistency;
        }
        set consistency(value: Consistency) {
            pb_1.Message.setField(this, 1, value);
        }
        get received() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set received(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get block_for() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set block_for(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get write_type() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set write_type(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        toObject() {
            const data: {
                consistency?: Consistency;
                received?: number;
                block_for?: number;
                write_type?: string;
            } = {};
            if (this.consistency != null) {
                data.consistency = this.consistency;
            }
            if (this.received != null) {
                data.received = this.received;
            }
            if (this.block_for != null) {
                data.block_for = this.block_for;
            }
            if (this.write_type != null) {
                data.write_type = this.write_type;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.consistency !== undefined)
                writer.writeEnum(1, this.consistency);
            if (this.received !== undefined)
                writer.writeInt32(2, this.received);
            if (this.block_for !== undefined)
                writer.writeInt32(3, this.block_for);
            if (typeof this.write_type === "string" && this.write_type.length)
                writer.writeString(4, this.write_type);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WriteTimeout {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WriteTimeout();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.consistency = reader.readEnum();
                        break;
                    case 2:
                        message.received = reader.readInt32();
                        break;
                    case 3:
                        message.block_for = reader.readInt32();
                        break;
                    case 4:
                        message.write_type = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): WriteTimeout {
            return WriteTimeout.deserialize(bytes);
        }
    }
    export class ReadTimeout extends pb_1.Message {
        constructor(data?: any[] | {
            consistency?: Consistency;
            received?: number;
            block_for?: number;
            data_present?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("consistency" in data && data.consistency != undefined) {
                    this.consistency = data.consistency;
                }
                if ("received" in data && data.received != undefined) {
                    this.received = data.received;
                }
                if ("block_for" in data && data.block_for != undefined) {
                    this.block_for = data.block_for;
                }
                if ("data_present" in data && data.data_present != undefined) {
                    this.data_present = data.data_present;
                }
            }
        }
        get consistency() {
            return pb_1.Message.getField(this, 1) as Consistency;
        }
        set consistency(value: Consistency) {
            pb_1.Message.setField(this, 1, value);
        }
        get received() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set received(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get block_for() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set block_for(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get data_present() {
            return pb_1.Message.getField(this, 4) as boolean;
        }
        set data_present(value: boolean) {
            pb_1.Message.setField(this, 4, value);
        }
        toObject() {
            const data: {
                consistency?: Consistency;
                received?: number;
                block_for?: number;
                data_present?: boolean;
            } = {};
            if (this.consistency != null) {
                data.consistency = this.consistency;
            }
            if (this.received != null) {
                data.received = this.received;
            }
            if (this.block_for != null) {
                data.block_for = this.block_for;
            }
            if (this.data_present != null) {
                data.data_present = this.data_present;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.consistency !== undefined)
                writer.writeEnum(1, this.consistency);
            if (this.received !== undefined)
                writer.writeInt32(2, this.received);
            if (this.block_for !== undefined)
                writer.writeInt32(3, this.block_for);
            if (this.data_present !== undefined)
                writer.writeBool(4, this.data_present);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReadTimeout {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReadTimeout();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.consistency = reader.readEnum();
                        break;
                    case 2:
                        message.received = reader.readInt32();
                        break;
                    case 3:
                        message.block_for = reader.readInt32();
                        break;
                    case 4:
                        message.data_present = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReadTimeout {
            return ReadTimeout.deserialize(bytes);
        }
    }
    export class ReadFailure extends pb_1.Message {
        constructor(data?: any[] | {
            consistency?: Consistency;
            received?: number;
            block_for?: number;
            num_failures?: number;
            data_present?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("consistency" in data && data.consistency != undefined) {
                    this.consistency = data.consistency;
                }
                if ("received" in data && data.received != undefined) {
                    this.received = data.received;
                }
                if ("block_for" in data && data.block_for != undefined) {
                    this.block_for = data.block_for;
                }
                if ("num_failures" in data && data.num_failures != undefined) {
                    this.num_failures = data.num_failures;
                }
                if ("data_present" in data && data.data_present != undefined) {
                    this.data_present = data.data_present;
                }
            }
        }
        get consistency() {
            return pb_1.Message.getField(this, 1) as Consistency;
        }
        set consistency(value: Consistency) {
            pb_1.Message.setField(this, 1, value);
        }
        get received() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set received(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get block_for() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set block_for(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get num_failures() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set num_failures(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get data_present() {
            return pb_1.Message.getField(this, 5) as boolean;
        }
        set data_present(value: boolean) {
            pb_1.Message.setField(this, 5, value);
        }
        toObject() {
            const data: {
                consistency?: Consistency;
                received?: number;
                block_for?: number;
                num_failures?: number;
                data_present?: boolean;
            } = {};
            if (this.consistency != null) {
                data.consistency = this.consistency;
            }
            if (this.received != null) {
                data.received = this.received;
            }
            if (this.block_for != null) {
                data.block_for = this.block_for;
            }
            if (this.num_failures != null) {
                data.num_failures = this.num_failures;
            }
            if (this.data_present != null) {
                data.data_present = this.data_present;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.consistency !== undefined)
                writer.writeEnum(1, this.consistency);
            if (this.received !== undefined)
                writer.writeInt32(2, this.received);
            if (this.block_for !== undefined)
                writer.writeInt32(3, this.block_for);
            if (this.num_failures !== undefined)
                writer.writeInt32(4, this.num_failures);
            if (this.data_present !== undefined)
                writer.writeBool(5, this.data_present);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReadFailure {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReadFailure();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.consistency = reader.readEnum();
                        break;
                    case 2:
                        message.received = reader.readInt32();
                        break;
                    case 3:
                        message.block_for = reader.readInt32();
                        break;
                    case 4:
                        message.num_failures = reader.readInt32();
                        break;
                    case 5:
                        message.data_present = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReadFailure {
            return ReadFailure.deserialize(bytes);
        }
    }
    export class FunctionFailure extends pb_1.Message {
        constructor(data?: any[] | {
            keyspace?: string;
            function?: string;
            arg_types?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("keyspace" in data && data.keyspace != undefined) {
                    this.keyspace = data.keyspace;
                }
                if ("function" in data && data.function != undefined) {
                    this.function = data.function;
                }
                if ("arg_types" in data && data.arg_types != undefined) {
                    this.arg_types = data.arg_types;
                }
            }
        }
        get keyspace() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set keyspace(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get function() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set function(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get arg_types() {
            return pb_1.Message.getField(this, 3) as string[];
        }
        set arg_types(value: string[]) {
            pb_1.Message.setField(this, 3, value);
        }
        toObject() {
            const data: {
                keyspace?: string;
                function?: string;
                arg_types?: string[];
            } = {};
            if (this.keyspace != null) {
                data.keyspace = this.keyspace;
            }
            if (this.function != null) {
                data.function = this.function;
            }
            if (this.arg_types != null) {
                data.arg_types = this.arg_types;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.keyspace === "string" && this.keyspace.length)
                writer.writeString(1, this.keyspace);
            if (typeof this.function === "string" && this.function.length)
                writer.writeString(2, this.function);
            if (this.arg_types !== undefined)
                writer.writeRepeatedString(3, this.arg_types);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FunctionFailure {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new FunctionFailure();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.keyspace = reader.readString();
                        break;
                    case 2:
                        message.function = reader.readString();
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): FunctionFailure {
            return FunctionFailure.deserialize(bytes);
        }
    }
    export class WriteFailure extends pb_1.Message {
        constructor(data?: any[] | {
            consistency?: Consistency;
            received?: number;
            block_for?: number;
            num_failures?: number;
            write_type?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("consistency" in data && data.consistency != undefined) {
                    this.consistency = data.consistency;
                }
                if ("received" in data && data.received != undefined) {
                    this.received = data.received;
                }
                if ("block_for" in data && data.block_for != undefined) {
                    this.block_for = data.block_for;
                }
                if ("num_failures" in data && data.num_failures != undefined) {
                    this.num_failures = data.num_failures;
                }
                if ("write_type" in data && data.write_type != undefined) {
                    this.write_type = data.write_type;
                }
            }
        }
        get consistency() {
            return pb_1.Message.getField(this, 1) as Consistency;
        }
        set consistency(value: Consistency) {
            pb_1.Message.setField(this, 1, value);
        }
        get received() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set received(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get block_for() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set block_for(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get num_failures() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set num_failures(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get write_type() {
            return pb_1.Message.getField(this, 5) as string;
        }
        set write_type(value: string) {
            pb_1.Message.setField(this, 5, value);
        }
        toObject() {
            const data: {
                consistency?: Consistency;
                received?: number;
                block_for?: number;
                num_failures?: number;
                write_type?: string;
            } = {};
            if (this.consistency != null) {
                data.consistency = this.consistency;
            }
            if (this.received != null) {
                data.received = this.received;
            }
            if (this.block_for != null) {
                data.block_for = this.block_for;
            }
            if (this.num_failures != null) {
                data.num_failures = this.num_failures;
            }
            if (this.write_type != null) {
                data.write_type = this.write_type;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.consistency !== undefined)
                writer.writeEnum(1, this.consistency);
            if (this.received !== undefined)
                writer.writeInt32(2, this.received);
            if (this.block_for !== undefined)
                writer.writeInt32(3, this.block_for);
            if (this.num_failures !== undefined)
                writer.writeInt32(4, this.num_failures);
            if (typeof this.write_type === "string" && this.write_type.length)
                writer.writeString(5, this.write_type);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WriteFailure {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WriteFailure();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.consistency = reader.readEnum();
                        break;
                    case 2:
                        message.received = reader.readInt32();
                        break;
                    case 3:
                        message.block_for = reader.readInt32();
                        break;
                    case 4:
                        message.num_failures = reader.readInt32();
                        break;
                    case 5:
                        message.write_type = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): WriteFailure {
            return WriteFailure.deserialize(bytes);
        }
    }
    export class AlreadyExists extends pb_1.Message {
        constructor(data?: any[] | {
            keyspace?: string;
            table?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("keyspace" in data && data.keyspace != undefined) {
                    this.keyspace = data.keyspace;
                }
                if ("table" in data && data.table != undefined) {
                    this.table = data.table;
                }
            }
        }
        get keyspace() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set keyspace(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get table() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set table(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        toObject() {
            const data: {
                keyspace?: string;
                table?: string;
            } = {};
            if (this.keyspace != null) {
                data.keyspace = this.keyspace;
            }
            if (this.table != null) {
                data.table = this.table;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.keyspace === "string" && this.keyspace.length)
                writer.writeString(1, this.keyspace);
            if (typeof this.table === "string" && this.table.length)
                writer.writeString(2, this.table);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AlreadyExists {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AlreadyExists();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.keyspace = reader.readString();
                        break;
                    case 2:
                        message.table = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AlreadyExists {
            return AlreadyExists.deserialize(bytes);
        }
    }
    export class CasWriteUnknown extends pb_1.Message {
        constructor(data?: any[] | {
            consistency?: Consistency;
            received?: number;
            block_for?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("consistency" in data && data.consistency != undefined) {
                    this.consistency = data.consistency;
                }
                if ("received" in data && data.received != undefined) {
                    this.received = data.received;
                }
                if ("block_for" in data && data.block_for != undefined) {
                    this.block_for = data.block_for;
                }
            }
        }
        get consistency() {
            return pb_1.Message.getField(this, 1) as Consistency;
        }
        set consistency(value: Consistency) {
            pb_1.Message.setField(this, 1, value);
        }
        get received() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set received(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get block_for() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set block_for(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        toObject() {
            const data: {
                consistency?: Consistency;
                received?: number;
                block_for?: number;
            } = {};
            if (this.consistency != null) {
                data.consistency = this.consistency;
            }
            if (this.received != null) {
                data.received = this.received;
            }
            if (this.block_for != null) {
                data.block_for = this.block_for;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.consistency !== undefined)
                writer.writeEnum(1, this.consistency);
            if (this.received !== undefined)
                writer.writeInt32(2, this.received);
            if (this.block_for !== undefined)
                writer.writeInt32(3, this.block_for);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CasWriteUnknown {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CasWriteUnknown();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.consistency = reader.readEnum();
                        break;
                    case 2:
                        message.received = reader.readInt32();
                        break;
                    case 3:
                        message.block_for = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CasWriteUnknown {
            return CasWriteUnknown.deserialize(bytes);
        }
    }
    export class Row extends pb_1.Message {
        constructor(data?: any[] | {
            values?: Value[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("values" in data && data.values != undefined) {
                    this.values = data.values;
                }
            }
        }
        get values() {
            return pb_1.Message.getRepeatedWrapperField(this, Value, 1) as Value[];
        }
        set values(value: Value[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        toObject() {
            const data: {
                values?: ReturnType<typeof Value.prototype.toObject>[];
            } = {};
            if (this.values != null) {
                data.values = this.values.map((item: Value) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.values !== undefined)
                writer.writeRepeatedMessage(1, this.values, (item: Value) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Row {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Row();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.values, () => pb_1.Message.addToRepeatedWrapperField(message, 1, Value.deserialize(reader), Value));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Row {
            return Row.deserialize(bytes);
        }
    }
    export class ResultSet extends pb_1.Message {
        constructor(data?: any[] | {
            columns?: ColumnSpec[];
            rows?: Row[];
            paging_state?: dependency_2.google.protobuf.BytesValue;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("columns" in data && data.columns != undefined) {
                    this.columns = data.columns;
                }
                if ("rows" in data && data.rows != undefined) {
                    this.rows = data.rows;
                }
                if ("paging_state" in data && data.paging_state != undefined) {
                    this.paging_state = data.paging_state;
                }
            }
        }
        get columns() {
            return pb_1.Message.getRepeatedWrapperField(this, ColumnSpec, 1) as ColumnSpec[];
        }
        set columns(value: ColumnSpec[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get rows() {
            return pb_1.Message.getRepeatedWrapperField(this, Row, 2) as Row[];
        }
        set rows(value: Row[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get paging_state() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.BytesValue, 3) as dependency_2.google.protobuf.BytesValue;
        }
        set paging_state(value: dependency_2.google.protobuf.BytesValue) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        toObject() {
            const data: {
                columns?: ReturnType<typeof ColumnSpec.prototype.toObject>[];
                rows?: ReturnType<typeof Row.prototype.toObject>[];
                paging_state?: ReturnType<typeof dependency_2.google.protobuf.BytesValue.prototype.toObject>;
            } = {};
            if (this.columns != null) {
                data.columns = this.columns.map((item: ColumnSpec) => item.toObject());
            }
            if (this.rows != null) {
                data.rows = this.rows.map((item: Row) => item.toObject());
            }
            if (this.paging_state != null) {
                data.paging_state = this.paging_state.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.columns !== undefined)
                writer.writeRepeatedMessage(1, this.columns, (item: ColumnSpec) => item.serialize(writer));
            if (this.rows !== undefined)
                writer.writeRepeatedMessage(2, this.rows, (item: Row) => item.serialize(writer));
            if (this.paging_state !== undefined)
                writer.writeMessage(3, this.paging_state, () => this.paging_state.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ResultSet {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ResultSet();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.columns, () => pb_1.Message.addToRepeatedWrapperField(message, 1, ColumnSpec.deserialize(reader), ColumnSpec));
                        break;
                    case 2:
                        reader.readMessage(message.rows, () => pb_1.Message.addToRepeatedWrapperField(message, 2, Row.deserialize(reader), Row));
                        break;
                    case 3:
                        reader.readMessage(message.paging_state, () => message.paging_state = dependency_2.google.protobuf.BytesValue.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ResultSet {
            return ResultSet.deserialize(bytes);
        }
    }
    export class BatchQuery extends pb_1.Message {
        constructor(data?: any[] | {
            cql?: string;
            values?: Payload;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("cql" in data && data.cql != undefined) {
                    this.cql = data.cql;
                }
                if ("values" in data && data.values != undefined) {
                    this.values = data.values;
                }
            }
        }
        get cql() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set cql(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get values() {
            return pb_1.Message.getWrapperField(this, Payload, 2) as Payload;
        }
        set values(value: Payload) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        toObject() {
            const data: {
                cql?: string;
                values?: ReturnType<typeof Payload.prototype.toObject>;
            } = {};
            if (this.cql != null) {
                data.cql = this.cql;
            }
            if (this.values != null) {
                data.values = this.values.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (typeof this.cql === "string" && this.cql.length)
                writer.writeString(1, this.cql);
            if (this.values !== undefined)
                writer.writeMessage(2, this.values, () => this.values.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BatchQuery {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BatchQuery();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.cql = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.values, () => message.values = Payload.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BatchQuery {
            return BatchQuery.deserialize(bytes);
        }
    }
    export class BatchParameters extends pb_1.Message {
        constructor(data?: any[] | {
            keyspace?: dependency_2.google.protobuf.StringValue;
            consistency?: ConsistencyValue;
            tracing?: boolean;
            timestamp?: dependency_2.google.protobuf.Int64Value;
            serial_consistency?: ConsistencyValue;
            now_in_seconds?: dependency_2.google.protobuf.Int32Value;
            tracing_consistency?: ConsistencyValue;
            skip_metadata?: boolean;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("keyspace" in data && data.keyspace != undefined) {
                    this.keyspace = data.keyspace;
                }
                if ("consistency" in data && data.consistency != undefined) {
                    this.consistency = data.consistency;
                }
                if ("tracing" in data && data.tracing != undefined) {
                    this.tracing = data.tracing;
                }
                if ("timestamp" in data && data.timestamp != undefined) {
                    this.timestamp = data.timestamp;
                }
                if ("serial_consistency" in data && data.serial_consistency != undefined) {
                    this.serial_consistency = data.serial_consistency;
                }
                if ("now_in_seconds" in data && data.now_in_seconds != undefined) {
                    this.now_in_seconds = data.now_in_seconds;
                }
                if ("tracing_consistency" in data && data.tracing_consistency != undefined) {
                    this.tracing_consistency = data.tracing_consistency;
                }
                if ("skip_metadata" in data && data.skip_metadata != undefined) {
                    this.skip_metadata = data.skip_metadata;
                }
            }
        }
        get keyspace() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.StringValue, 1) as dependency_2.google.protobuf.StringValue;
        }
        set keyspace(value: dependency_2.google.protobuf.StringValue) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get consistency() {
            return pb_1.Message.getWrapperField(this, ConsistencyValue, 2) as ConsistencyValue;
        }
        set consistency(value: ConsistencyValue) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get tracing() {
            return pb_1.Message.getField(this, 3) as boolean;
        }
        set tracing(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get timestamp() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Int64Value, 4) as dependency_2.google.protobuf.Int64Value;
        }
        set timestamp(value: dependency_2.google.protobuf.Int64Value) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get serial_consistency() {
            return pb_1.Message.getWrapperField(this, ConsistencyValue, 5) as ConsistencyValue;
        }
        set serial_consistency(value: ConsistencyValue) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get now_in_seconds() {
            return pb_1.Message.getWrapperField(this, dependency_2.google.protobuf.Int32Value, 6) as dependency_2.google.protobuf.Int32Value;
        }
        set now_in_seconds(value: dependency_2.google.protobuf.Int32Value) {
            pb_1.Message.setWrapperField(this, 6, value);
        }
        get tracing_consistency() {
            return pb_1.Message.getWrapperField(this, ConsistencyValue, 7) as ConsistencyValue;
        }
        set tracing_consistency(value: ConsistencyValue) {
            pb_1.Message.setWrapperField(this, 7, value);
        }
        get skip_metadata() {
            return pb_1.Message.getField(this, 8) as boolean;
        }
        set skip_metadata(value: boolean) {
            pb_1.Message.setField(this, 8, value);
        }
        toObject() {
            const data: {
                keyspace?: ReturnType<typeof dependency_2.google.protobuf.StringValue.prototype.toObject>;
                consistency?: ReturnType<typeof ConsistencyValue.prototype.toObject>;
                tracing?: boolean;
                timestamp?: ReturnType<typeof dependency_2.google.protobuf.Int64Value.prototype.toObject>;
                serial_consistency?: ReturnType<typeof ConsistencyValue.prototype.toObject>;
                now_in_seconds?: ReturnType<typeof dependency_2.google.protobuf.Int32Value.prototype.toObject>;
                tracing_consistency?: ReturnType<typeof ConsistencyValue.prototype.toObject>;
                skip_metadata?: boolean;
            } = {};
            if (this.keyspace != null) {
                data.keyspace = this.keyspace.toObject();
            }
            if (this.consistency != null) {
                data.consistency = this.consistency.toObject();
            }
            if (this.tracing != null) {
                data.tracing = this.tracing;
            }
            if (this.timestamp != null) {
                data.timestamp = this.timestamp.toObject();
            }
            if (this.serial_consistency != null) {
                data.serial_consistency = this.serial_consistency.toObject();
            }
            if (this.now_in_seconds != null) {
                data.now_in_seconds = this.now_in_seconds.toObject();
            }
            if (this.tracing_consistency != null) {
                data.tracing_consistency = this.tracing_consistency.toObject();
            }
            if (this.skip_metadata != null) {
                data.skip_metadata = this.skip_metadata;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.keyspace !== undefined)
                writer.writeMessage(1, this.keyspace, () => this.keyspace.serialize(writer));
            if (this.consistency !== undefined)
                writer.writeMessage(2, this.consistency, () => this.consistency.serialize(writer));
            if (this.tracing !== undefined)
                writer.writeBool(3, this.tracing);
            if (this.timestamp !== undefined)
                writer.writeMessage(4, this.timestamp, () => this.timestamp.serialize(writer));
            if (this.serial_consistency !== undefined)
                writer.writeMessage(5, this.serial_consistency, () => this.serial_consistency.serialize(writer));
            if (this.now_in_seconds !== undefined)
                writer.writeMessage(6, this.now_in_seconds, () => this.now_in_seconds.serialize(writer));
            if (this.tracing_consistency !== undefined)
                writer.writeMessage(7, this.tracing_consistency, () => this.tracing_consistency.serialize(writer));
            if (this.skip_metadata !== undefined)
                writer.writeBool(8, this.skip_metadata);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): BatchParameters {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new BatchParameters();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.keyspace, () => message.keyspace = dependency_2.google.protobuf.StringValue.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.consistency, () => message.consistency = ConsistencyValue.deserialize(reader));
                        break;
                    case 3:
                        message.tracing = reader.readBool();
                        break;
                    case 4:
                        reader.readMessage(message.timestamp, () => message.timestamp = dependency_2.google.protobuf.Int64Value.deserialize(reader));
                        break;
                    case 5:
                        reader.readMessage(message.serial_consistency, () => message.serial_consistency = ConsistencyValue.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.now_in_seconds, () => message.now_in_seconds = dependency_2.google.protobuf.Int32Value.deserialize(reader));
                        break;
                    case 7:
                        reader.readMessage(message.tracing_consistency, () => message.tracing_consistency = ConsistencyValue.deserialize(reader));
                        break;
                    case 8:
                        message.skip_metadata = reader.readBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): BatchParameters {
            return BatchParameters.deserialize(bytes);
        }
    }
    export class Batch extends pb_1.Message {
        constructor(data?: any[] | {
            type?: Batch.Type;
            queries?: BatchQuery[];
            parameters?: BatchParameters;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], []);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("queries" in data && data.queries != undefined) {
                    this.queries = data.queries;
                }
                if ("parameters" in data && data.parameters != undefined) {
                    this.parameters = data.parameters;
                }
            }
        }
        get type() {
            return pb_1.Message.getField(this, 1) as Batch.Type;
        }
        set type(value: Batch.Type) {
            pb_1.Message.setField(this, 1, value);
        }
        get queries() {
            return pb_1.Message.getRepeatedWrapperField(this, BatchQuery, 2) as BatchQuery[];
        }
        set queries(value: BatchQuery[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get parameters() {
            return pb_1.Message.getWrapperField(this, BatchParameters, 3) as BatchParameters;
        }
        set parameters(value: BatchParameters) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        toObject() {
            const data: {
                type?: Batch.Type;
                queries?: ReturnType<typeof BatchQuery.prototype.toObject>[];
                parameters?: ReturnType<typeof BatchParameters.prototype.toObject>;
            } = {};
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.queries != null) {
                data.queries = this.queries.map((item: BatchQuery) => item.toObject());
            }
            if (this.parameters != null) {
                data.parameters = this.parameters.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.type !== undefined)
                writer.writeEnum(1, this.type);
            if (this.queries !== undefined)
                writer.writeRepeatedMessage(2, this.queries, (item: BatchQuery) => item.serialize(writer));
            if (this.parameters !== undefined)
                writer.writeMessage(3, this.parameters, () => this.parameters.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Batch {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Batch();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.type = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.queries, () => pb_1.Message.addToRepeatedWrapperField(message, 2, BatchQuery.deserialize(reader), BatchQuery));
                        break;
                    case 3:
                        reader.readMessage(message.parameters, () => message.parameters = BatchParameters.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Batch {
            return Batch.deserialize(bytes);
        }
    }
    export namespace Batch {
        export enum Type {
            LOGGED = 0,
            UNLOGGED = 1,
            COUNTER = 2
        }
    }
}
